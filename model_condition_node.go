/*
dofusdude

# Open Ankama Developer Community The all-in-one toolbelt for your next Ankama related project.  ## Versions - [Dofus 2](https://docs.dofusdu.de/dofus2/) - [Dofus 3](https://docs.dofusdu.de/dofus3/)   - v1 [latest] (you are here)   ## Client SDKs - [Javascript](https://github.com/dofusdude/dofusdude-js) `npm i dofusdude-js --save` - [Typescript](https://github.com/dofusdude/dofusdude-ts) `npm i dofusdude-ts --save` - [Go](https://github.com/dofusdude/dodugo) `go get -u github.com/dofusdude/dodugo` - [Python](https://github.com/dofusdude/dofusdude-py) `pip install dofusdude` - [Java](https://github.com/dofusdude/dofusdude-java) Maven with GitHub packages setup  Everything, including this site, is generated out of the [Docs Repo](https://github.com/dofusdude/api-docs). Consider it the Single Source of Truth. If there is a problem with the SDKs, create an issue there.  Your favorite language is missing? Please let me know!  # Main Features - 🥷 **Seamless Auto-Update** load data in the background when a new Dofus version is released and serving it within 10 minutes with atomic data source switching. No downtime and no effects for the user, just always up-to-date.  - ⚡ **Blazingly Fast** all data in-memory, aggressive caching over short time spans, HTTP/2 multiplexing, written in Go, optimized for low latency, hosted on bare metal in 🇩🇪.  - 📨 **Almanax Discord Integration** Use the endpoints as a dev or the official [Web Client](https://discord.dofusdude.com) as a user.  - 🩸 **Dofus 3 Beta** from stable to bleeding edge by replacing /dofus3 with /dofus3beta.  - 🗣️ **Multilingual** supporting _en_, _fr_, _es_, _pt_, _de_.  - 🧠 **Search by Relevance** allowing typos in name and description, handled by language specific text analysis and indexing.  - 🕵️ **Official Sources** generated from actual data from the game.  ... and much more on the Roadmap on my [Discord](https://discord.gg/3EtHskZD8h). 

API version: 1.0.0-rc.9
Contact: stelzo@steado.de
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dodugo

import (
	"encoding/json"
	"fmt"
	"gopkg.in/validator.v2"
)

// ConditionNode - struct for ConditionNode
type ConditionNode struct {
	ConditionLeaf *ConditionLeaf
	ConditionRelation *ConditionRelation
}

// ConditionLeafAsConditionNode is a convenience function that returns ConditionLeaf wrapped in ConditionNode
func ConditionLeafAsConditionNode(v *ConditionLeaf) ConditionNode {
	return ConditionNode{
		ConditionLeaf: v,
	}
}

// ConditionRelationAsConditionNode is a convenience function that returns ConditionRelation wrapped in ConditionNode
func ConditionRelationAsConditionNode(v *ConditionRelation) ConditionNode {
	return ConditionNode{
		ConditionRelation: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *ConditionNode) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into ConditionLeaf
	err = newStrictDecoder(data).Decode(&dst.ConditionLeaf)
	if err == nil {
		jsonConditionLeaf, _ := json.Marshal(dst.ConditionLeaf)
		if string(jsonConditionLeaf) == "{}" { // empty struct
			dst.ConditionLeaf = nil
		} else {
			if err = validator.Validate(dst.ConditionLeaf); err != nil {
				dst.ConditionLeaf = nil
			} else {
				match++
			}
		}
	} else {
		dst.ConditionLeaf = nil
	}

	// try to unmarshal data into ConditionRelation
	err = newStrictDecoder(data).Decode(&dst.ConditionRelation)
	if err == nil {
		jsonConditionRelation, _ := json.Marshal(dst.ConditionRelation)
		if string(jsonConditionRelation) == "{}" { // empty struct
			dst.ConditionRelation = nil
		} else {
			if err = validator.Validate(dst.ConditionRelation); err != nil {
				dst.ConditionRelation = nil
			} else {
				match++
			}
		}
	} else {
		dst.ConditionRelation = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.ConditionLeaf = nil
		dst.ConditionRelation = nil

		return fmt.Errorf("data matches more than one schema in oneOf(ConditionNode)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(ConditionNode)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src ConditionNode) MarshalJSON() ([]byte, error) {
	if src.ConditionLeaf != nil {
		return json.Marshal(&src.ConditionLeaf)
	}

	if src.ConditionRelation != nil {
		return json.Marshal(&src.ConditionRelation)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *ConditionNode) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.ConditionLeaf != nil {
		return obj.ConditionLeaf
	}

	if obj.ConditionRelation != nil {
		return obj.ConditionRelation
	}

	// all schemas are nil
	return nil
}

type NullableConditionNode struct {
	value *ConditionNode
	isSet bool
}

func (v NullableConditionNode) Get() *ConditionNode {
	return v.value
}

func (v *NullableConditionNode) Set(val *ConditionNode) {
	v.value = val
	v.isSet = true
}

func (v NullableConditionNode) IsSet() bool {
	return v.isSet
}

func (v *NullableConditionNode) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableConditionNode(val *ConditionNode) *NullableConditionNode {
	return &NullableConditionNode{value: val, isSet: true}
}

func (v NullableConditionNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableConditionNode) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


