/*
dofusdude

# A project for you - the developer. The all-in-one toolbelt for your next Ankama related project.  ## Client SDKs - [Javascript](https://github.com/dofusdude/dofusdude-js) `npm i dofusdude-js --save` - [Typescript](https://github.com/dofusdude/dofusdude-ts) `npm i dofusdude-ts --save` - [Go](https://github.com/dofusdude/dodugo) `go get -u github.com/dofusdude/dodugo` - [Python](https://github.com/dofusdude/dofusdude-py) `pip install dofusdude` - [PHP](https://github.com/dofusdude/dofusdude-php) - [Java](https://github.com/dofusdude/dofusdude-java) Maven with GitHub packages setup  Everything, including this site, is generated out of the [Docs Repo](https://github.com/dofusdude/api-docs). Consider it the Single Source of Truth. If there is a problem with the SDKs, create an issue there.  Your favorite language is missing? Please let me know!  # Main Features - 🥷 **Seamless Auto-Update** load data in the background when a new Dofus version is released and serving it within 10 minutes with atomic data source switching. No downtime and no effects for the user, just always up-to-date.  - ⚡ **Blazingly Fast** all data in-memory, aggressive caching over short time spans, HTTP/2 multiplexing, written in Go, optimized for low latency, hosted on bare metal in 🇩🇪.  - 📨 **Discord Integration** Ankama related RSS and Almanax feeds to post to Discord servers with advanced features like filters or mentions. Use the endpoints as a dev or the official [Web Client](https://discord.dofusdude.com) as a user.  - 🩸 **Dofus 2 Beta** from stable to bleeding edge by replacing /dofus2 with /dofus2beta.  - 🗣️ **Multilingual** supporting _en_, _fr_, _es_, _pt_ including the dropped languages from the Dofus website _de_ and _it_.  - 🧠 **Search by Relevance** allowing typos in name and description, handled by language specific text analysis and indexing.  - 🕵️ **Complete** actual data from the game including items invisible to the encyclopedia like quest items.  - 🖼️ **HD Images** rendering game assets to high-res images with up to 800x800 px.  ... and much more on the Roadmap on my [Discord](https://discord.gg/3EtHskZD8h). 

API version: 0.9.0
Contact: stelzo@steado.de
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dodugo

import (
	"encoding/json"
	"fmt"
)

// ConditionTreeNode - struct for ConditionTreeNode
type ConditionTreeNode struct {
	ConditionTreeLeaf *ConditionTreeLeaf
	ConditionTreeRelation *ConditionTreeRelation
}

// ConditionTreeLeafAsConditionTreeNode is a convenience function that returns ConditionTreeLeaf wrapped in ConditionTreeNode
func ConditionTreeLeafAsConditionTreeNode(v *ConditionTreeLeaf) ConditionTreeNode {
	return ConditionTreeNode{
		ConditionTreeLeaf: v,
	}
}

// ConditionTreeRelationAsConditionTreeNode is a convenience function that returns ConditionTreeRelation wrapped in ConditionTreeNode
func ConditionTreeRelationAsConditionTreeNode(v *ConditionTreeRelation) ConditionTreeNode {
	return ConditionTreeNode{
		ConditionTreeRelation: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *ConditionTreeNode) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into ConditionTreeLeaf
	err = newStrictDecoder(data).Decode(&dst.ConditionTreeLeaf)
	if err == nil {
		jsonConditionTreeLeaf, _ := json.Marshal(dst.ConditionTreeLeaf)
		if string(jsonConditionTreeLeaf) == "{}" { // empty struct
			dst.ConditionTreeLeaf = nil
		} else {
			match++
		}
	} else {
		dst.ConditionTreeLeaf = nil
	}

	// try to unmarshal data into ConditionTreeRelation
	err = newStrictDecoder(data).Decode(&dst.ConditionTreeRelation)
	if err == nil {
		jsonConditionTreeRelation, _ := json.Marshal(dst.ConditionTreeRelation)
		if string(jsonConditionTreeRelation) == "{}" { // empty struct
			dst.ConditionTreeRelation = nil
		} else {
			match++
		}
	} else {
		dst.ConditionTreeRelation = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.ConditionTreeLeaf = nil
		dst.ConditionTreeRelation = nil

		return fmt.Errorf("data matches more than one schema in oneOf(ConditionTreeNode)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(ConditionTreeNode)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src ConditionTreeNode) MarshalJSON() ([]byte, error) {
	if src.ConditionTreeLeaf != nil {
		return json.Marshal(&src.ConditionTreeLeaf)
	}

	if src.ConditionTreeRelation != nil {
		return json.Marshal(&src.ConditionTreeRelation)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *ConditionTreeNode) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.ConditionTreeLeaf != nil {
		return obj.ConditionTreeLeaf
	}

	if obj.ConditionTreeRelation != nil {
		return obj.ConditionTreeRelation
	}

	// all schemas are nil
	return nil
}

type NullableConditionTreeNode struct {
	value *ConditionTreeNode
	isSet bool
}

func (v NullableConditionTreeNode) Get() *ConditionTreeNode {
	return v.value
}

func (v *NullableConditionTreeNode) Set(val *ConditionTreeNode) {
	v.value = val
	v.isSet = true
}

func (v NullableConditionTreeNode) IsSet() bool {
	return v.isSet
}

func (v *NullableConditionTreeNode) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableConditionTreeNode(val *ConditionTreeNode) *NullableConditionTreeNode {
	return &NullableConditionTreeNode{value: val, isSet: true}
}

func (v NullableConditionTreeNode) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableConditionTreeNode) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


